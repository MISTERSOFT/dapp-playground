/**
 * Class that interact directly with the blockchain, espcially the Contract TodoList
 */
class TodosBlockchain {
    constructor() {
        // Sepolia temporary email/pwd: ripipo2036@farebus.com / ripipo2036@farebus.com

        // A Web3Provider wraps a standard Web3 provider, which is what MetaMask injects as window.ethereum into each page
        this.provider = new ethers.providers.Web3Provider(window.ethereum);
        this.todoListContract = undefined;
        this.onAccountsChangedHandler = undefined;
        // Address of the contract deployed on the blockchain
        // NOTE: Everytime we change & deploy the contract we need to change this address.
        this.contractAddress = '0x1CCDBa0755a44192c191EA6c7952022693523B02'; // '0xcC58A33088501B22001EeF044b047be976eC4e72';
        // NOTE to me: Better way to get the ABI is to load the metadata TodoList JSON file generated by the Solidity compiler
        this.contractABI = [
            {
                "inputs": [
                    {
                        "internalType": "string",
                        "name": "text",
                        "type": "string"
                    },
                    {
                        "internalType": "bool",
                        "name": "done",
                        "type": "bool"
                    }
                ],
                "name": "addTodo",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "id",
                        "type": "uint256"
                    }
                ],
                "name": "deleteTodo",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [],
                "name": "TodoAdded",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [],
                "name": "TodoDeleted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [],
                "name": "TodoUpdated",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "id",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "done",
                        "type": "bool"
                    }
                ],
                "name": "updateTodo",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getTodos",
                "outputs": [
                    {
                        "components": [
                            {
                                "internalType": "uint256",
                                "name": "id",
                                "type": "uint256"
                            },
                            {
                                "internalType": "string",
                                "name": "text",
                                "type": "string"
                            },
                            {
                                "internalType": "bool",
                                "name": "done",
                                "type": "bool"
                            },
                            {
                                "internalType": "bool",
                                "name": "deleted",
                                "type": "bool"
                            }
                        ],
                        "internalType": "struct Todo[]",
                        "name": "",
                        "type": "tuple[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];
    }

    /**
     * Try to retrieve wallet data a the initialization.
     * @param {*} options 
     */
    async init(options) {
        const {
            onAccountsChanged,
        } = options;
        this.onAccountsChangedHandler = (accounts) => {
            onAccountsChanged(accounts);

            if (accounts.length === 0) {
                return;
            }

            // get todolist contract
            const signer =  this.provider.getSigner();
            this.todoListContract = new ethers.Contract(this.contractAddress, this.contractABI, signer);
        };

        // Check if Metamask is connected (https://stackoverflow.com/a/71265025)
        this.provider.on('accountsChanged', this.onAccountsChangedHandler);
        await this.checkAccounts();
    }

    /**
     * Ask Metamask to share wallet informations with the website.
     */
    async connect() {
        const accounts = await this.provider.send("eth_requestAccounts", []);
        console.log('connect()', accounts);
        this.onAccountsChangedHandler(accounts);
    }

    /**
     * Check accounts available on Metamask (empty array if user hasn't allow Metamask to share informations with the website).
     */
    async checkAccounts() {
        const accounts = await this.provider.send("eth_accounts", []);
        console.log('checkAccounts()', accounts);
        this.onAccountsChangedHandler(accounts);
    }

    async getTodos() {
        const todos = await this.todoListContract.getTodos();
        console.log('todos fetched', todos);
        return todos;
    }

    async addTodo(text, done) {
        // Send data to contract
        const tx = await this.todoListContract.addTodo(text, done);
        console.log('addTodo tx', tx);
        // Then wait transaction to be computed by the blockchain
        await tx.wait();
    }

    async updateTodo(id, done) {
        // Send data to contract
        const tx = await this.todoListContract.updateTodo(id, done);
        console.log('updateTodo tx', tx);
        // Then wait transaction to be computed by the blockchain
        await tx.wait();
    }

    async deleteTodo(id) {
        // Send data to contract
        const tx = await this.todoListContract.deleteTodo(id);
        console.log('deleteTodo tx', tx);
        // Then wait transaction to be computed by the blockchain
        await tx.wait();
    }
}

/**
 * Class that manage the DOM tree of the TODO list
 */
class TodoList {
    constructor(blockchain) {
        this.todoListElement = document.querySelector('[data-tasklist]');
        this.blockchain = blockchain;
    }

    /**
     * Generated a GUID
     * @returns GUID
     */
    uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }

    /**
     * Create a LI HTML element with todo data
     * @param {*} todo 
     * @returns LI HTML Element
     */
    createTodoElement(todo, handlers) {
        // <li class="list-group-item">
        //     <input class="form-check-input me-1" type="checkbox" value="" id="firstCheckbox">
        //     <label class="form-check-label" for="firstCheckbox">First checkbox</label>
        //     <button type="button" class="btn btn-danger">Delete</button>
        // </li>

        const { onCheckChange, onDeleteClick } = handlers;
        const { id, text, done } = todo;

        const li = document.createElement('li');
        li.classList.add('list-group-item', 'd-flex', 'align-items-center', 'justify-content-between');

        const inputId = this.uuidv4();

        const div = document.createElement('div');

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = inputId;
        input.checked = done;
        input.classList.add('form-check-input', 'me-1');

        const label = document.createElement('label');
        label.setAttribute('for', inputId);
        label.classList.add('form-check-label');
        if (done) {
            label.classList.add('text-decoration-line-through');
        }
        label.innerHTML = text;
        
        const btn = document.createElement('button');
        btn.innerHTML = 'Delete';
        btn.classList.add('btn', 'btn-sm', 'btn-danger');

        div.appendChild(input);
        div.appendChild(label);
        li.appendChild(div);
        li.appendChild(btn);

        input.addEventListener('change', (e) => {
            onCheckChange(e, id);
        });
        btn.addEventListener('click', () => {
            onDeleteClick(id);
        });

        return li;
    }

    /**
     * Refresh todos list
     */
    async refresh() {
        const todos = await this.blockchain.getTodos();

        // clear all tasks from the list
        this.todoListElement.innerHTML = '';

        // regenerate all task elements
        const todoElements = todos.map(todo => this.createTodoElement(todo, {
            onCheckChange: async (event, id) => {
                const checked = event.target.checked;
                try {
                    await this.updateTodo(id, checked);
                } catch (e) {
                    event.target.checked = !checked;
                }
            },
            onDeleteClick: async (id) => {
                await this.deleteTodo(id);
            }
        }));
        todoElements.forEach(todoElement => this.todoListElement.appendChild(todoElement));
    }

    async addTodo() {
        const input = document.querySelector('input[type="text"]');

        await this.blockchain.addTodo(input.value, false);

        // When transaction is done, we refresh the list. At this moment we are sure the data sent earlier are stored in the blockchain.
        await this.refresh();
    }

    async updateTodo(id, done) {
        await this.blockchain.updateTodo(id, done);

        // When transaction is done, we refresh the list. At this moment we are sure the data sent earlier are stored in the blockchain.
        await this.refresh();
    }

    async deleteTodo(id) {
        await this.blockchain.deleteTodo(id);

        // When transaction is done, we refresh the list. At this moment we are sure the data sent earlier are stored in the blockchain.
        await this.refresh();
    }
}


// Entry point

(async () => {
    const connectWalletBtn = document.querySelector('button[data-connect-wallet-button]');
    const connectWalletSuccessElement = document.querySelector('[data-connect-wallet-success]');
    const todoListContainerElement = document.querySelector('[data-todolist-container]');
    const addBtn = document.querySelector('button[data-add-button]');

    
    const todosBlockchain = new TodosBlockchain();

    await todosBlockchain.init({
        onAccountsChanged: (accounts) => {
            if (accounts.length) {
                // hide connect button and show message
                connectWalletBtn.classList.add('d-none');
                connectWalletSuccessElement.classList.remove('d-none');
                // allow user add todos
                todoListContainerElement.classList.remove('disabled-todolist');
            } else {
                // show connect button and hide message
                connectWalletBtn.classList.remove('d-none');
                connectWalletSuccessElement.classList.add('d-none');
                // disable todolist
                todoListContainerElement.classList.add('disabled-todolist');
            }
        }
    });

    connectWalletBtn.addEventListener('click', () => {
        todosBlockchain.connect();
    });
    
    const todoList = new TodoList(todosBlockchain);
    
    addBtn.addEventListener('click', async () => {
        await todoList.addTodo();
    });

    // Refresh the list on DApp load
    await todoList.refresh();
})();